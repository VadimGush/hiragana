/**
 * Responsible for all logic related to reviews.
 */
import { Language } from "@/core/Language";

type Collection = ReviewCard[];

/**
 * Picks cards to review
 */
interface CardPicker {
  /**
   * Returns a card to review (might return the same card)
   */
  pick(): ReviewCard;

  /**
   * Called whenever a card with a specific id is
   * answered correctly
   */
  correct(id: number): void;

  /**
   * Called whenever a cart with a specific id is
   * answered incorrectly
   */
  incorrect(id: number): void;

  /**
   * How many times Picker.pick() method should be called
   * before the review will be treated as completed.
   */
  totalCards(): number;
}

/**
 * Picks cards randomly.
 */
export class RandomPicker implements CardPicker {
  // Collection of all cards for this review
  collection: Collection = [];
  // How many times a specific card was picked
  cardPicked: Array<number> = [];

  constructor(collection: Collection) {
    collection.forEach((card, i) => {
      card.assignId(i);
      this.cardPicked.push(0);
      this.collection.push(card);
    });
  }

  pick(): ReviewCard {
    // Find cards that were answered the least amount of time
    const minNumberPicked = this.cardPicked.reduce((l, r) => Math.min(l, r));
    // Get IDs of all of those cards
    const minIds: number[] = [];
    this.cardPicked.forEach((v, i) => {
      if (v == minNumberPicked) {
        minIds.push(i);
      }
    });
    // Take a random card from this array
    const id = minIds[Math.floor(Math.random() * minIds.length)];

    // Marked as already picked
    this.cardPicked[id] += 1;
    return this.collection[id];
  }

  correct(id: number) {
    return undefined;
  }
  incorrect(id: number) {
    return undefined;
  }
  totalCards(): number {
    return this.collection.length;
  }
}

/**
 * Represents a review of some set of cards.
 * Which cards will be picked is desided by the
 * implementation of the Picker.
 */
export class Review {
  picker: CardPicker;

  // Monitors answer time for the current card
  cardAnswerTime = new Map<number, number>();
  cardTimeStart: number = Date.now();

  // All cards generated by Picker.pick();
  generatedCards = new Map<number, ReviewCard>();
  // All cards that completed (answered correctly)
  completedCardsIds = new Set<number>();
  // All cards that were answered without any mistakes
  correctCardsIds = new Set<number>();
  // All cards that were answered with at least one mistake
  incorrectCardsIds = new Set<number>();

  constructor(picker: CardPicker, kana = "") {
    this.picker = picker;
  }

  completed(): boolean {
    return this.completedCardsIds.size == this.picker.totalCards();
  }

  take(): ReviewCard {
    this.cardTimeStart = Date.now();

    // Look for cards that were unswered incorrectly
    const incorrectCardsToReview: number[] = [];
    this.incorrectCardsIds.forEach((i) => {
      if (!this.completedCardsIds.has(i)) {
        incorrectCardsToReview.push(i);
      }
    });

    // If there are no incorrectly answered cards to repeat
    // then pick a new one from the picker
    if (this.generatedCards.size < this.picker.totalCards()) {
      const card = this.picker.pick();
      this.generatedCards.set(card.id, card);
      return card;
    } else {
      const rid = Math.floor(Math.random() * incorrectCardsToReview.length);
      const id = incorrectCardsToReview[rid];
      return this.generatedCards.get(id)!;
    }
  }

  getCorrectCards(): ReviewCard[] {
    const result: ReviewCard[] = [];
    this.completedCardsIds.forEach((id) =>
      result.push(this.generatedCards.get(id)!)
    );
    return result;
  }

  getIncorrectCards(): ReviewCard[] {
    const result: ReviewCard[] = [];
    this.incorrectCardsIds.forEach((id) =>
      result.push(this.generatedCards.get(id)!)
    );
    return result;
  }

  /**
   * @returns progress of the current review (value from 0 to 1)
   */
  progress(): number {
    return this.completedCardsIds.size / this.picker.totalCards();
  }

  /**
   * Repeat the entire review from zero
   * @returns new review with the same cards
   */
  repeat(): Review {
    const collection: Collection = [];
    this.completedCardsIds.forEach((id) =>
      collection.push(this.generatedCards.get(id)!)
    );
    return new Review(new RandomPicker(collection));
  }

  /**
   * Repeat all cards that were answered incorrectly
   * during this review
   * @returns new review with incorrectly answered cards
   */
  repeatIncorrect(): Review {
    const collection: Collection = this.getIncorrectCards();
    return new Review(new RandomPicker(collection));
  }

  /**
   * @returns returns how much time user spent answering every card
   */
  getTimers(): number[] {
    const time: number[] = [];
    this.cardAnswerTime.forEach((v) => time.push(v));
    return time;
  }

  verify(card: ReviewCard, input: string): boolean {
    const rawInputMatchesAnswers = card.check(input);
    const romanjiMatchesAnswers = card.check(Language.toRomaji(input));
    const hiraganaMatchesAnsers = card.check(Language.toHiragana(input));
    const katakanaMatchesAnswers = card.check(Language.toKatakana(input));

    const correct =
      rawInputMatchesAnswers ||
      romanjiMatchesAnswers ||
      hiraganaMatchesAnsers ||
      katakanaMatchesAnswers;

    if (correct) {
      const timeToAnswer = (Date.now() - this.cardTimeStart) / 1000;
      this.cardAnswerTime.set(card.id, timeToAnswer);

      // Set as completed and correct if there were no mistakes
      this.completedCardsIds.add(card.id);
      if (!this.incorrectCardsIds.has(card.id)) {
        this.correctCardsIds.add(card.id);
      }

      // Notify picker that card was answered correctly
      this.picker.correct(card.id);
      return true;
    }

    if (!this.correctCardsIds.has(card.id)) {
      this.incorrectCardsIds.add(card.id);
    }
    // Notify picker that card was answered incorrectly
    this.picker.incorrect(card.id);
    return false;
  }
}

/**
 * Represents a review card.
 */
export class ReviewCard {
  id = 0;
  type = "";

  question = "";
  shownAnswers: string[] = [];
  answers: string[] = [];

  note = "";
  kana = "";

  static create(
    type: string,
    question: string,
    answers: string[],
    shownAnswers: string[] = [],
    kana = ""
  ): ReviewCard {
    const card = this.empty;
    card.type = type;
    card.question = question;
    card.answers = answers;
    card.kana = kana;
    if (shownAnswers.length == 0) {
      card.shownAnswers = answers;
    } else {
      card.shownAnswers = shownAnswers;
    }
    return card;
  }

  get answer(): string {
    return this.answers[0];
  }

  check(userAnswer: string): boolean {
    return (
      this.answers.find(
        (answer) => answer.toLowerCase() == userAnswer.toLowerCase()
      ) != undefined
    );
  }

  assignId(id: number) {
    this.id = id;
  }

  static get empty(): ReviewCard {
    return new ReviewCard();
  }
}
