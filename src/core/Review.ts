import Language from "./Language";

/**
 * Module contains everything related to reviews.
 * Including reviews implementation, cards, and etc.
 */
type Collection = ReviewCard[];

/**
 * Picks cards to review
 */
interface CardPicker {
  /**
   * Returns a card to review (might return the same card)
   */
  pick(): ReviewCard;

  /**
   * Called whenever a card with a specific id is
   * answered correctly
   */
  correct(id: number): void;

  /**
   * Called whenever a cart with a specific id is
   * answered incorrectly
   */
  incorrect(id: number): void;

  /**
   * How many times Picker.pick() method should be called
   * before the review will be treated as completed.
   */
  totalCards(): number;
}

/**
 * Picks cards randomly.
 */
export class RandomPicker implements CardPicker {
  // Collection of all cards for this review
  collection: Collection = [];
  // How many times a specific card was picked
  cardPicked: Array<number> = [];

  constructor(collection: Collection) {
    collection.forEach((card, i) => {
      card.id = i;
      this.cardPicked.push(0);
      this.collection.push(card);
    });
  }

  pick(): ReviewCard {
    // Find cards that were answered the least amount of time
    const minNumberPicked = this.cardPicked.reduce((l, r) => Math.min(l, r));
    // Get IDs of all of those cards
    const minIds: number[] = [];
    this.cardPicked.forEach((v, i) => {
      if (v == minNumberPicked) {
        minIds.push(i);
      }
    });
    // Take a random card from this array
    const id = minIds[Math.floor(Math.random() * minIds.length)];

    // Marked as already picked
    this.cardPicked[id] += 1;
    return this.collection[id];
  }

  correct(id: number) {
    return undefined;
  }
  incorrect(id: number) {
    return undefined;
  }
  totalCards(): number {
    return this.collection.length;
  }
}

/**
 * Represents a review of some set of cards.
 * Which cards will be picked is desided by the
 * implementation of the Picker.
 */
export class Review {
  picker: CardPicker;

  // Monitors answer time for the current card
  cardAnswerTime = new Map<number, number>();
  cardTimeStart: number = Date.now();

  // All cards generated by Picker.pick();
  generatedCards = new Map<number, ReviewCard>();
  // All cards that completed (answered correctly)
  completedCardsIds = new Set<number>();
  // All cards that were answered without any mistakes
  correctCardsIds = new Set<number>();
  // All cards that were answered with at least one mistake
  incorrectCardsIds = new Set<number>();

  constructor(picker: CardPicker, kana = "") {
    this.picker = picker;
  }

  completed(): boolean {
    return this.completedCardsIds.size == this.picker.totalCards();
  }

  take(): ReviewCard {
    this.cardTimeStart = Date.now();

    // Look for cards that were unswered incorrectly
    const incorrectCardsToReview: number[] = [];
    this.incorrectCardsIds.forEach((i) => {
      if (!this.completedCardsIds.has(i)) {
        incorrectCardsToReview.push(i);
      }
    });

    // If there are no incorrectly answered cards to repeat
    // then pick a new one from the picker
    if (this.generatedCards.size < this.picker.totalCards()) {
      const card = this.picker.pick();
      this.generatedCards.set(card.id, card);
      return card;
    } else {
      const rid = Math.floor(Math.random() * incorrectCardsToReview.length);
      const id = incorrectCardsToReview[rid];
      return this.generatedCards.get(id)!;
    }
  }

  getCorrectCards(): ReviewCard[] {
    const result: ReviewCard[] = [];
    this.completedCardsIds.forEach((id) => {
      if (!this.incorrectCardsIds.has(id)) {
        result.push(this.generatedCards.get(id)!);
      }
    });
    return result;
  }

  getIncorrectCards(): ReviewCard[] {
    const result: ReviewCard[] = [];
    this.incorrectCardsIds.forEach((id) =>
      result.push(this.generatedCards.get(id)!)
    );
    return result;
  }

  getTotalCardsCount(): number {
    return this.picker.totalCards();
  }

  /**
   * @returns progress of the current review (value from 0 to 1)
   */
  progress(): number {
    return this.completedCardsIds.size / this.picker.totalCards();
  }

  /**
   * Repeat the entire review from zero
   * @returns new review with the same cards
   */
  repeat(): Review {
    const collection: Collection = [];
    this.completedCardsIds.forEach((id) =>
      collection.push(this.generatedCards.get(id)!)
    );
    return new Review(new RandomPicker(collection));
  }

  /**
   * Repeat all cards that were answered incorrectly
   * during this review
   * @returns new review with incorrectly answered cards
   */
  repeatIncorrect(): Review {
    const collection: Collection = this.getIncorrectCards();
    return new Review(new RandomPicker(collection));
  }

  /**
   * @returns returns how much time user spent answering every card
   */
  getTimers(): number[] {
    const time: number[] = [];
    this.cardAnswerTime.forEach((v) => time.push(v));
    return time;
  }

  verify(card: ReviewCard, input: string): boolean {
    let correct = false;
    card.answers.forEach((answer) => {
      const i = input.toLowerCase();
      const a = answer.toLowerCase();
      if (card.type == "meaning" && Language.compare(a, i, 0.7)) {
        correct = true;
      } else if (a === i) {
        correct = true;
      }
    });

    if (correct) {
      const timeToAnswer = (Date.now() - this.cardTimeStart) / 1000;
      this.cardAnswerTime.set(card.id, timeToAnswer);

      // Set as completed and correct if there were no mistakes
      this.completedCardsIds.add(card.id);
      if (!this.incorrectCardsIds.has(card.id)) {
        this.correctCardsIds.add(card.id);
      }

      // Notify picker that card was answered correctly
      this.picker.correct(card.id);
      return true;
    }

    if (!this.correctCardsIds.has(card.id)) {
      this.incorrectCardsIds.add(card.id);
    }
    // Notify picker that card was answered incorrectly
    this.picker.incorrect(card.id);
    return false;
  }
}

type ReviewCardType = "reading" | "meaning" | "translation";
type ReviewCardInput = "romaji" | "hiragana" | "katakana";

type ReviewCardParams = {
  id?: number;
  type: ReviewCardType;
  question: string;
  shownAnswers?: string[];
  answers: string[];
  note?: string;
  input?: ReviewCardInput;
};

/**
 * Represents a review card
 */
export class ReviewCard {
  id: number;
  type: ReviewCardType;
  question: string;
  shownAnswers: string[];
  answers: string[];
  note: string;
  input: ReviewCardInput;

  constructor(params: ReviewCardParams) {
    this.id = params.id ?? 0;
    this.type = params.type;
    this.question = params.question;
    this.shownAnswers = params.shownAnswers ?? params.answers;
    this.answers = params.answers;
    this.note = params.note ?? "";
    this.input = params.input ?? "romaji";
  }
}
